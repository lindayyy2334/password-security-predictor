import streamlit as st
import numpy as np
import re
from io import BytesIO
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from datetime import datetime

# =========================
# PDF Generation Function
# =========================
def generate_pdf_report(score, risk_level, bf_time, dict_time, gpu_time, length, entropy, pattern_risk):
    """
    Generate a PDF password security report and return it as BytesIO.
    """
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    # Title
    c.setFont("Helvetica-Bold", 18)
    c.drawString(50, height - 50, "PASSWORD SECURITY REPORT")

    # Date & Basic Info
    c.setFont("Helvetica", 12)
    c.drawString(50, height - 80, f"Analysis Date: {datetime.now().strftime('%d %B %Y')}")
    c.drawString(50, height - 100, f"Security Score: {score}/100")
    c.drawString(50, height - 120, f"Risk Level: {risk_level}")

    # Estimated Crack Time
    c.drawString(50, height - 150, "Estimated Crack Time:")
    c.drawString(70, height - 170, f"- Brute Force: {bf_time}")
    c.drawString(70, height - 190, f"- Dictionary Attack: {dict_time}")
    c.drawString(70, height - 210, f"- GPU Attack: {gpu_time}")

    # Key Findings
    c.drawString(50, height - 240, "Key Findings:")
    c.drawString(70, height - 260, f"- Password Length: {length} characters")
    c.drawString(70, height - 280, f"- Entropy Level: {entropy}")
    c.drawString(70, height - 300, f"- Pattern Risk: {pattern_risk}")

    # Recommendations
    c.drawString(50, height - 330, "Recommendations:")
    c.drawString(70, height - 350, "- Increase length to at least 14+ characters")
    c.drawString(70, height - 370, "- Avoid dictionary-based words")
    c.drawString(70, height - 390, "- Use mixed character sets (A-Z, a-z, 0-9, symbols)")

    # Footer
    c.drawString(50, height - 430, "Generated by Password Risk Intelligence Platform")

    c.showPage()
    c.save()
    buffer.seek(0)
    return buffer

# =========================
# Password Analysis Function
# =========================
def analyze_password(pw):
    length = len(pw)
    score = min(length * 5, 50)
    if re.search(r"[A-Z]", pw): score += 10
    if re.search(r"[a-z]", pw): score += 10
    if re.search(r"\d", pw): score += 10
    if re.search(r"[!@#$%^&*(),.?\":{}|<>]", pw): score += 10
    score = min(score, 100)
    if score < 50: verdict = "DANGER"
    elif score < 80: verdict = "WEAK"
    else: verdict = "SECURE"

    w, b = 1.5, -5
    bf_seconds = np.exp(w*length + b)                 # Brute force
    dict_seconds = bf_seconds / 2                     # Simplified dictionary attack
    gpu_seconds = bf_seconds / 1000                   # GPU attack faster
    return score, verdict, bf_seconds, dict_seconds, gpu_seconds, length, "Medium", "Low"

# =========================
# Streamlit UI
# =========================
st.title("ðŸ” Password Fortress Security Predictor")

password = st.text_input("Enter your password:", type="password")

if password:
    score, verdict, bf_time, dict_time, gpu_time, length, entropy, pattern_risk = analyze_password(password)
    st.subheader("Password Analysis")
    st.write(f"Score: {score}/100 â€” {verdict}")
    st.write(f"Estimated Brute Force Crack Time: {bf_time:.2f} sec")
    st.write(f"Estimated Dictionary Crack Time: {dict_time:.2f} sec")
    st.write(f"Estimated GPU Crack Time: {gpu_time:.2f} sec")

    # Download PDF button
    pdf_buffer = generate_pdf_report(score, verdict, f"{bf_time:.2f} sec",
                                     f"{dict_time:.2f} sec", f"{gpu_time:.2f} sec",
                                     length, entropy, pattern_risk)
    st.download_button(
        label="ðŸ“„ Download PDF Report",
        data=pdf_buffer,
        file_name=f"Password_Report_{datetime.now().strftime('%Y%m%d')}.pdf",
        mime="application/pdf"
    )
